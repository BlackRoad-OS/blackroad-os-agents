/**
 * Pyto Python IDE Integration
 *
 * Provides integration with Pyto (iOS Python IDE) for mobile Python development.
 * Pyto uses x-callback-url scheme for automation.
 */

import type {
  Integration,
  IntegrationStatus,
  PytoConfig,
} from "./types.js";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";

interface PytoScript {
  name: string;
  code: string;
  description?: string;
  requirements?: string[];
}

export class PytoClient implements Integration {
  private config: PytoConfig;
  private initialized = false;
  private scriptsPath: string;

  constructor(config: PytoConfig) {
    this.config = config;
    this.scriptsPath =
      config.scriptsPath ||
      path.join(os.homedir(), ".config", "blackroad", "pyto");
  }

  async initialize(): Promise<void> {
    if (!fs.existsSync(this.scriptsPath)) {
      fs.mkdirSync(this.scriptsPath, { recursive: true });
    }
    this.initialized = true;
  }

  async getStatus(): Promise<IntegrationStatus> {
    return {
      connected: true,
      healthy: true,
      lastCheck: new Date(),
      metadata: {
        scriptsPath: this.scriptsPath,
        platform: "ios",
      },
    };
  }

  async cleanup(): Promise<void> {
    this.initialized = false;
  }

  /**
   * Generate Pyto URL for running code
   */
  generateRunURL(code: string): string {
    const params = new URLSearchParams({
      code: Buffer.from(code).toString("base64"),
    });

    return `pyto://run?${params.toString()}`;
  }

  /**
   * Generate Pyto URL for opening a script
   */
  generateOpenURL(scriptPath: string): string {
    const params = new URLSearchParams({
      path: scriptPath,
    });

    return `pyto://open?${params.toString()}`;
  }

  /**
   * Generate Pyto URL for installing a package
   */
  generateInstallURL(packageName: string): string {
    const params = new URLSearchParams({
      package: packageName,
    });

    return `pyto://pip?${params.toString()}`;
  }

  /**
   * Save a script locally for syncing
   */
  async saveScript(script: PytoScript): Promise<boolean> {
    const scriptPath = path.join(
      this.scriptsPath,
      `${script.name.replace(/\s+/g, "_")}.py`
    );

    let content = `#!/usr/bin/env python3
"""
${script.description || script.name}

Generated by BlackRoad OS Agents
"""

`;

    if (script.requirements?.length) {
      content += `# Requirements: ${script.requirements.join(", ")}\n`;
      for (const req of script.requirements) {
        content += `# pip install ${req}\n`;
      }
      content += "\n";
    }

    content += script.code;

    fs.writeFileSync(scriptPath, content);

    // Save metadata
    const metadataPath = path.join(this.scriptsPath, "scripts.json");
    let scripts: PytoScript[] = [];

    if (fs.existsSync(metadataPath)) {
      scripts = JSON.parse(fs.readFileSync(metadataPath, "utf-8"));
    }

    const existingIndex = scripts.findIndex((s) => s.name === script.name);
    if (existingIndex >= 0) {
      scripts[existingIndex] = script;
    } else {
      scripts.push(script);
    }

    fs.writeFileSync(metadataPath, JSON.stringify(scripts, null, 2));
    return true;
  }

  /**
   * Get all saved scripts
   */
  async getScripts(): Promise<PytoScript[]> {
    const metadataPath = path.join(this.scriptsPath, "scripts.json");
    if (!fs.existsSync(metadataPath)) {
      return [];
    }
    return JSON.parse(fs.readFileSync(metadataPath, "utf-8"));
  }

  /**
   * Remove a script
   */
  async removeScript(scriptName: string): Promise<boolean> {
    const scriptPath = path.join(
      this.scriptsPath,
      `${scriptName.replace(/\s+/g, "_")}.py`
    );

    if (fs.existsSync(scriptPath)) {
      fs.unlinkSync(scriptPath);
    }

    const metadataPath = path.join(this.scriptsPath, "scripts.json");
    if (!fs.existsSync(metadataPath)) {
      return false;
    }

    const scripts: PytoScript[] = JSON.parse(
      fs.readFileSync(metadataPath, "utf-8")
    );
    const newScripts = scripts.filter((s) => s.name !== scriptName);

    if (newScripts.length === scripts.length) {
      return false;
    }

    fs.writeFileSync(metadataPath, JSON.stringify(newScripts, null, 2));
    return true;
  }

  /**
   * Setup BlackRoad Python scripts
   */
  async setupBlackRoadScripts(): Promise<boolean> {
    const scripts: PytoScript[] = [
      {
        name: "blackroad_status",
        description: "Check BlackRoad agent status from iOS",
        requirements: ["requests"],
        code: `
import requests
import json

# BlackRoad Agent API
API_URL = "http://your-pi-ip:8080"
AUTH_TOKEN = "your-token"

def get_status():
    headers = {"Authorization": f"Bearer {AUTH_TOKEN}"}
    try:
        response = requests.get(f"{API_URL}/status", headers=headers)
        data = response.json()
        print("BlackRoad Agent Status")
        print("=" * 40)
        print(f"Pi: {json.dumps(data.get('pi', {}), indent=2)}")
        print(f"Jetson: {json.dumps(data.get('jetson', {}), indent=2)}")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    get_status()
`,
      },
      {
        name: "blackroad_deploy",
        description: "Deploy to BlackRoad from iOS",
        requirements: ["requests"],
        code: `
import requests
import sys

# BlackRoad Agent API
API_URL = "http://your-pi-ip:8080"
AUTH_TOKEN = "your-token"

def deploy(command):
    headers = {
        "Authorization": f"Bearer {AUTH_TOKEN}",
        "Content-Type": "application/json"
    }
    payload = {"command": command}

    try:
        response = requests.post(f"{API_URL}/run", headers=headers, json=payload)
        data = response.json()
        print(f"Success: {data.get('ok')}")
        if data.get('stdout'):
            print(f"Output: {data['stdout']}")
        if data.get('stderr'):
            print(f"Errors: {data['stderr']}")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        deploy(" ".join(sys.argv[1:]))
    else:
        deploy("systemctl status blackroad-agent")
`,
      },
      {
        name: "blackroad_telemetry",
        description: "View BlackRoad telemetry data",
        requirements: ["requests", "rich"],
        code: `
import requests
from rich.console import Console
from rich.table import Table

# BlackRoad Agent API
API_URL = "http://your-pi-ip:8080"

console = Console()

def show_telemetry():
    try:
        response = requests.get(f"{API_URL}/telemetry/local")
        data = response.json()

        table = Table(title="BlackRoad Telemetry")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")

        for key, value in data.items():
            table.add_row(key, str(value))

        console.print(table)
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")

if __name__ == "__main__":
    show_telemetry()
`,
      },
    ];

    for (const script of scripts) {
      await this.saveScript(script);
    }

    return true;
  }

  /**
   * Generate requirements.txt content
   */
  generateRequirements(scripts: PytoScript[]): string {
    const requirements = new Set<string>();
    for (const script of scripts) {
      for (const req of script.requirements || []) {
        requirements.add(req);
      }
    }
    return Array.from(requirements).join("\n");
  }
}
